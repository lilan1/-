# 选择排序

#### 原理

首先，找到整个数组中最小的那个元素，然后将该元素与数组的第一个元素进行交换，，其次，再在剩下的元素中找到最小的那个元素，将他与数组中的第二个元素交换位置，如此往复，直到将整个数组排序完毕。

#### 特点

+ 运行时间和输入无关
+ 数据移动是最少的

#### 实现

+ 代码

  ```javascript
  var swap = function (array, index1, index2) {
  	var aux = array[index1];
  	array[index1] = array[index2];
  	array[index2] = aux;
  }
  
  var selectionSort = function (array) {
  	var length = array.length,
  				indexMin;
  	for (var i = 0; i < length - 1; i++) {
  		indexMin = i;
  		for (var j = i; j < length; j++) {
  			if (array[indexMin] > array[j]) {
  			indexMin = j; 
  			}
  		}
  		if (i !== indexMin) {
  			swap(array, i, indexMin); 
  		}
  	} 
  	return array;
  }
  ```

+ 时间复杂度：O(n<sup>2</sup>)



# 冒泡排序

#### 原理



#### 特点



#### 实现

+ 代码

  ```
  function mao(arr) {
  	var len = arr.length;
  	var temp;
  	while (len > 0) {
  		for (var i = 0; i < len-1; i++) {
  			if(arr[i]>arr[i+1]){
  				temp = arr[i];
  				arr[i] = arr[i+1];
  				arr[i+1] = temp;
  			}
  		}
  		len--;
  	}
  	return arr;
  }
  ```

+ 时间复杂度





# 快速排序

#### 原理



#### 特点



#### 实现

+ 代码

  ```
  function selectionSort(arr) {
  	var minIndex;
  	var N = arr.length;
  	var temp;
  	for (let i = 0; i < N; i++) {
  		minIndex = i;
  		for (var j = i; j < N; j++) {
  			if (arr[minIndex] > arr[j]) minIndex = j;
  		}
  		if (minIndex != i) {
  			temp = arr[minIndex];
  			arr[minIndex] = arr[i];
  			arr[i] = temp;
  		}
  	}
  	return arr;
  }
  ```

  

+ 时间复杂度