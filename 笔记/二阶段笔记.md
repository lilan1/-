语言基础

1. JavaScript历史

2. JavaScript组成

   核心（ECMAScript）

   文档对象模型（DOM）（html标签）

   浏览器对象模型（BOM）

3. JavaScript引入及写法

   + 内部书写

     + 位于head部分的脚本

       全部的JavaScript代码都被下载、解析和执行完成之后，才能开始呈现页面的内容，浏览器在遇到body标签才开始呈现内容

     + 位于body部分的脚本，不推荐将js语句放在HTML标签中

       优点：解决了上面的问题

   + 外部引入（推荐），head和body均可以```<script src="./a.js"></script>```，**添加目录的时候一定要加"./"，尽量不使用"../"，禁止使用绝对路径，也可以使用网络地址**

     优点：

     + 可维护性
     + 可缓存
     + 适应未来：通过使用外部文件包含JavaScript代码，无需使用XHTML或注释hack

     1.  如果加载的js中，变量或者函数相同的时候，就会覆盖，这种情况叫做变量污染

   + 直接写在行内

   + ES6的代码引入和写法

   1. 从上向下解释性文档，上面的代码无法调用下面的标签和脚本
   2. 浏览器的自动纠正，script脚本放在HTML标签外面的时候，浏览器会将script标签放在body的最下面，**可利用**，但是不建议，因为会消耗浏览器的性能

4. 注释

   + 单行注释，双斜杠//
   + 块注释/**/，可以用来注释一行中的部分代码

   1. 工作的时候，不用的代码不要删除，注释掉
   2. 自己写的代码要写注释

5. 调试，F12断点调试

   + preformance，录制操作占用内存
   + memory，记录操作快照，展示内存具体使用信息

6. js语言基本标准

   + 分号结尾，英文半角
   + 大小写严格
     + 一般首字母都是小写，除了类
     + 一般都是驼峰命名规则
   + 提示信息```alert(message?:any:void)```含义：message指参数名称（_default表示默认值，...text表示可以有多个），？可以写值也可以不写，:any返回值类型任意，:void表示不返回值

7. 常用方法

   + console.log()
   + alert()    弹出框
   + confirm()    确认消息框
   + prompt()    提示消息框，给用户提供输入窗口

8. 语句块，通常来说，用大括号包裹的一组JavaScript语句称为语句块

9. 变量

   + JavaScript关键字
   	```txt
     break  do  instanceof  typeof  case  else  new  var  catch  finally  return  void  continue  for  switch  while  function  this  with  default  if  throw  delete  in  try
     ```
     
   + JavaScript保留字，使用保留字命名不报错，但是不能使用

     ```txt
     abstract  int  short  boolean  export  interface    static  byte  extends  long  super  char  final  native  class  float  throws  const  goto  private  double  import  public
     ```
     
   + JavaScript变量

     + ES5，IE8时代支持的js标准，ES6 2015开始正式使用，又称为ES2015

     + JavaScript的变量是松散类型的，所谓的松散类型就是可以用来保存任何类型的数据

     + 不推荐创建全局变量，污染全局命名空间

     + 定义未初始化的值：undefined

     + 一条语句定义多个变量，逗号分隔

     + =赋值也是有返回值的，返回等号右边的值

     + 连等赋值，a=b=3，先赋值给a，再赋值给b，运行过程是先将（b=3）的返回值赋值给a，再将3赋值给b，任何赋值都是有返回值的

     + ES5中不允许直接使用变量的赋值，必须前面加一个var声明变量的赋值

     + 如果不使用var声明，name这个变量就一定从属于window，而在函数以外的地方使用var声明，也是设置了window的属性，也从属于window

     + 变量的命名规则：

       1. 驼峰式命名
       2. 临时变量必须使用下划线起头后面接驼峰式命名，有时候也会在函数的参数中使用临时变量
       3. 全局的变量名不能与window下的属性和方法同名，不报错，但是会覆盖本来的函数
       
     + window下的变量status固定为字符串，使用代码提示检测变量名是否是关键字
     
     + const常量，常量名称必须大写，并且使用下划线区分单词
     
       使用常量的目的是，不会被别人修改或者变量污染
   
10. 数据类型

      + 字符串（string），反引号，双引号，单引号

      + 数字（number），各类进制（log会打印十进制）、整数、浮点数、带符号，科学计数法，布尔（boolean），数值型变量没有引用关系

      + NULL

        + typeof输出object

          原因：因为null多用于对象清空，字符类型、数值类型、布尔类型、未定义数据类型均不需要使用null进行回收

        + 空值是将所有引用地址标记清空，用于清理内存，垃圾回收

      + Undefined

        + 仅定义未初始化
    + 声明变量并初始化为undefined
        + 函数没有返回值时，默认返回undefined
    
        1. ```var b = undefined;```，一般用于将原有值的变量设置为undeifned 

      + 对象
    
        1. 无序键值对
        
           ```
           var d="add";
           var obj={
           	name:"李岚",
           	age:18,
           	"tel":17700000000,    //不建议
           	[d]:"天津市"    //变量作为key必须在外层增加中括号
           }
           console.log(obj[d]);    //调用变量作为key的属性
           console.log(obj["name"]);
           console.log(obj.age);
           ```
        
        2. ```
           var obj={};
           含义是空对象，盒子为空
           
           obj=null;
           含义是空，盒子都扔了
           ```
        
        3. 对象中不能出现重复的属性
    
      1. typeof操作符用来检测变量的数据类型，是个操作符，不是函数
  2. JavaScript不支持任何创建自定义类型的机制
    
11. 数据类型转换

       1. 数值转换

          + 数字转换为字符串

            1.   

               ```
               var a = 3;
               var b = String(a);
               ```

            2. 隐式转换（依据运算特征）

               ```
               a = a + "";
               自动执行String(a)方法，然后进行相加
               ```

            3. toString(number)

               实际上是对象的方法，万物皆对象，所有的变量都有该方法

               toString()方法的参数必须是2-36之间的整数，表示进制，转换为特定的进制数值

               ```
               var a = 15;
               a = a.toString(16);
               console.log(a);
               此时输出F
               ```

            4. toFixed(number)

               参数为浮点位，表示小数点后面保存的位数，15~15.00，自动四舍五入

               a = a.toFixed(2)

            5. toExponential()

               + 将数值格式化为科学计数法
               + 参数值的范围是0~20
               + 参数值表示科学计数法小数点后面的位数，当数值的位数超出参数指定范围的时候，进行四舍五入

            6. toPrecision()

               + 将数值格式化为指定的长度，参数字、表示长度
               + 当对象的值超出指定位数时，将其格式化为科学计数法，不够的时候用小数点后面的0来凑

          + 数值转换为布尔值

            1. 只有0转换成布尔值是false

            2. 强制转换（只能Boolean()强制转换）

               ```
               var a = 0;
               a = Boolean(a);
               console.log(a);
               //false
               ```

          + 数值转换为对象---->数值型对象

            1. Object()

               ```
               var a = 0;
               a = Object(a);
               console.log(a);
               输出为0
               typeof a//输出为Object
               ```

               数值型对象可以加减，具有数值特征，存储在堆中

       2. 字符串转换

          + 字符串转换为数值

            1. Number()

               ```
               var a = "a";
               a = Number(a);
               console.log(a);
               输出NaN
               //NaN，数值类型中的非数值
               如果是字符串本身就是数值的，则可以正常转换
               ```

            2. parselnt()    

               + 字符串转换成整数

               + 两个参数，第一个参数是需要转换的值，第二个参数表示按照几进制接收

                 ```
                 var a = "101";
                 a = parseInt(a,2);
                 //此时输出a为5
                 ```

            3. parseFloat()    字符串转换成浮点数，不能转换进制

            4. 注意：

               + 后面两个函数在转换"32a"这种的时候会转换成32，省略不符合数值特征的部分，而Number会报错，隐式转换遵从Number

               + Number的转换，"32 "(32+空格)，--->32，"32 1"---->NaN，首尾有空格会自动去除，但是中间有不可以，会被认定为字符，但是后面两个函数会省略中间空格后面的内容进行数制转换

          + 字符串转换为布尔值    Boolean()

            1. 仅空字符串转换为布尔值时，被认定为false，除此之外全部是true
            2. 空格不是空字符串，空格是true

          + 字符串转换为对象    Object()    转换后为字符串对象

       3. 布尔值转换

          + 布尔值转换为数值，true转换为1，false转换为0
          + 布尔值转换为字符
          + 布尔值转换为对象，转换后为布尔对象
          + 任何类型转换为布尔值
            1. false：空字符串、0，NaN、false、null、undefined
            2. 除了上面六种情况均为true

       4. undefined、null转换为字符串和数值

          + 字符串转换结果为字符串的undefined和null
          + zhaunhu数值Number转换结果为undefined--->NaN，null--->0
          + 转换为数值parseInt转换结果为undefined--->NaN，null--->NaN

          注意：

          1. 数据类型转换分为强制转换和隐式转换

          2. 字符串方法trim()

             ```
             var a = "   li lan  ";
             a = a.trim();
             清除字符串前后空格，中间不管
             ```

12. 定义变量的常用方法

    + 尽量不要使用连等赋值变量定义
    + 有值变量定义最好换行定义，按照类型定义，将类型分开定义，比较清楚

14. 运算符
    + 算术运算符：加减乘除、取模%

        1. “+”号两端出现字符串的话，就会变成字符串拼接，数值、布尔值、undefined、Null通过String隐式转换为字符串

        2. “+”号两端没有出现字符串，其他非数值类型就会转换为数值并相加

        3. 所有类型遇到“-”、“*”、“/”和“%”的时候，都会隐式转换为数值进行运算

        4. 浮点运算存在误差

        5. 加法运算符结果

           ![](D:\GP-2002\笔记\img\加法运算符.png)

    + 一元运算符：累加++、递减--

        1. ++a和a++

           累加（递减）在前，先返回后运算，以+1后的结果参加运算

           累加（递减）在后，先运算后返回，以a参加运算，+1前

        2. 对于累加和递减，通常都会直接使用算数运算来处理

           会先将内容隐式转换为数值，然后再运算

           ```
           var a = "3";
           var b = a++;
           //b输出结果为数值3
           将字符串隐式转换为数值的一种方式
           
           这种恶心吧啦的式子随便拆
           b=a+++a+++a+a+++a+a
       b=a+++(a=a+a)+a++*2
          ```

           

    + 关系运算符：大于、大于等于、小于、小于等于、等于、严格相等、不等、非严格相等

       1. 关系运算符尽可能使用三个等号，判断更严谨

          ```
          console.log(""==false);
          console.log(0=="");
          console.log(0==false);
          上面全是true
          
          下面是false
          console.log(0==null);
          
          独立相等，返回true，且不与""、0、false相等，这三个彼此相等
          console.log(undefined==null);
          
          特殊：NaN，NaN跟任何值都不相等，包括他自身，NaN==NaN-->false
       判断NaN，使用isNaN(a)
          ```
          
          ```
          var a = 0;
                 if (a == false){
                 	console.log("aa");
                 	//a--> 0 false
                 }
                 if (a === false){
                 	console.log("aa");
                 	//a-->false
                 }
                 if (!a){
                 	console.log("aa");
                 	//a--> 0  null  false  undefined  ""  NaN
                 }
                 if (a == null){
                 	console.log("aa");
                 	//a--> undefined  null
                 }
                 if (a === undefined){
              	console.log("aa");
                 	//a--> undefined
            }
          ```
          
          **不同数据类型之间的“==”抽象相等比较**
          
          number的优先级最高，所有的类型都尽量转换为number进行处理
       
    + 逻辑运算符：逻辑非！、逻辑与&&、逻辑或||

       1. 得到的结果不一定是布尔值

          + 第一个值  &&  第二个值

            当第一个值为假，结果为第二个值；第一个值为真，结果为第一个值

          + 第一个值  ||  第二个值

            当第一个值为假，结果为第二个值；第一个值为真，结果为第一个值
            
            ```
            var obj = {a:2};
            obj = obj || {a:1}
            console.log(obj);
            如果obj转换为布尔值是false，直接熔断
            ```

       2. 逻辑非可以用来做开关、多选框的反选

    + 赋值运算符（运算符优先级低）：

      1. 乘法/赋值（*=）

      2. 除法/赋值（/=）

      3. 取模/赋值（%=）

      4. 加法/赋值（+=）

         ```a+=""```，将a隐式转换为字符串

      5. 减法/赋值（-=）

      6. 左移/赋值（<<=），二进制移位

      7. 有符号右移/赋值（>>=）

      8. 无符号右移/赋值（>>>=）

    + 位运算符

       1. 位非运算符（~）    加1取负
       2. 位与运算符（&）
       3. 位或运算符（|）
       4. 位异或运算符（^） 同0异1
       5. 左移位运算符（<<）
       6. 右移位运算符（>>）

    + 条件运算表达式

       1. 条件语句 ？ 语句1 ：语句2;

          判断条件是否成立，成立执行语句1，不成立执行语句2

       + 三目运算符优先级比赋值运算符高
       + 当返回的是布尔值的时候，不要使用三目运算符
       + 问号前面的内容会隐式转换为布尔值
       + 不要将条件运算表达式复杂化，尽量不要使用赋值运算符

15. 运算符优先级
    + 赋值运算符的优先级最低
    + 一元运算符优先级很高，比乘除高
    + 强制优先级：加括号

16. 表达式

# 流程控制语句

### 条件语句

1. 只有一条语句的时候，可以不加大括号

   ```
   if(){
   }
   ```

   ```
   if(){
   }else{
   }
   ```

   ```
   if(){
   }else if{
   }else if{
   }else{
   }
   ```

2. switch case

   ```
   switch(表达式)
   {
   	case 值1:
   		语句1;
   		break;
   	case 值2:
   		语句2;
   		break;
   	default:
   		语句3;
   }
   ```

   + 表达式和值1必须是严格相等才会执行语句1，值也可以是运算式
   + break是必须的，如果值1没有break，程序不会判断表达式是否与值2严格相等，直接执行语句2，这种现象叫做穿越
   + 穿越现象会被利用减少代码量，减少重复代码
   + switch经常会被用来做状态机
   + 特点：严格相等、判决条件清晰、可穿越

3. 条件不管是什么表达式，都会隐式转换为布尔值

4. 常用运算符：非！（非真进入）

### 循环语句

+ 禁止出现重复代码
+ 要将代码尽可能进行加精简

1. while    先判断后循环，循环体有可能一次也不执行，循环体应包含使循环结束的语句

   ```
   while（判断语句）｛
   	循环体；
   ｝
   ```

   + 在大量运行时，while的效率高于for，推荐使用while

2. do while    先运行后判断，至少运行一次

   ```
   do
   {
      循环体;    
      循环增量;
   }while(循环条件)
   ```

   + 常使用++i
   + 使用场景较少

3. for

   ```
   for(var i=0;i<10;i++){
   	console.log(i)
   }
   ```

   ```
   var i = 0,sum = 0;
   for(i = 0;i++ < 100;sum += i);
   ```

    + ```for(语句1;语句2;语句3){}```
       语句3所在位置的语句块的含义是，一次循环执行完毕之后一定会要执行的语句，不一定是变量不断变化的语句
       
    + 典型的死循环
      
       ```
       for(;;){
       }
       ```
4. for-in**待补充**
5. for-each**待补充**
6. for-of**待补充**
7. map循环**待补充**

+ 使用循环的时候，一定要尽可能避免循环定义变量
+ 使用循环的时候，一定要注意临界值
+ 在双重循环的时候，不要在内层中判断外层变量或者改变外层变量
+ 循环条件均会隐式转换为布尔值
+ 如果使用break的时候，不写跳出label的时候，它只会跳出当前循环
+ 循环是同步的，循环的总次数不要超过亿，嵌套的更要注意
+ 六种循环中while相对来说效率比较高，递归循环的时间复杂度最低
+ ```document.body.innerHTML = str```会将body内原本的内容替换掉，将等号换成 += 就可以了

### break    

1. 可以跳转到指定的ID位置

### continue    

1. 处理循环中阶段性不符合条件的时候，可以使用continue
2. 支持跳转ID

# 对象

### 类和对象的概念

### 对象创建

1. var obj=new Object();
2. var obj={}
3. var obj=Object.creat({});**自己补充**

### 对象的属性和方法

1. 对象基础

   ```
   var d="add";
   var obj={
   	name:"李岚",
   	age:18,
   	"tel":17700000000,    //不建议
   	[d]:"天津市",   //变量作为key必须在外层增加中括号
   	9:10
   }
   console.log(obj[d]);    //调用变量作为key的属性
   console.log(obj["name"]);
   console.log(obj.age);
   console.log(obj.9);    //点语法拒绝使用非字符类型属性
   console.log([9]);  //在对象中key除了字符类型以外只能支持symbol类型，数值会被隐式转换为字符
   ```
    + 对象的属性必须是字符串，否则不能使用点语法来获取
    + 点语法只能获取属性名明确的字符串属性
   ```
   var d = "add";
   var obj = {
   	name: "李岚",
   	age: 18,
   	"tel": 17700000000,    //不建议
   	[d]: "天津市"   //变量作为key必须在外层增加中括号
   	}
   	var a = {
   		aa : 30
   	}
   	var b = {
   		bb:70
   	}
   	var arr = [1,2,3]
   	var arr1 = [4,5,6]
   	obj[undefined] = 10;
   	obj[null] = 20;
   	obj[a] = 50;
   	obj[b] = 60;  //对象都会转换为[Object Object]，所以会覆盖前面的，但是数组不会覆盖
   	obj[arr] = 100;
   	obj[arr1] = 110;
   
   	console.log(obj[undefined]);
   	console.log(obj[null]);
   	console.log(obj[a]);
   	console.log(obj);
   ```

   运行结果

   ![](D:\GP-2002\笔记\img\对象运行结果.png)

2. 对象引用存储

   + 堆~存储空间，

     栈~临时存储，栈中存储堆中内容的地址

     ```
     var obj = {
     	a:1
     }
     console.log(obj);
     obj.a = 10;
     ```

     第一次运行结果

     ![](D:\GP-2002\笔记\img\对象引用存储1.png)

     结果说明：第一次运行，在浏览器缓存中没有关于obj对象的缓存，在点击左上角的小三角的去获取a的值的时候，整个浏览器才会去堆中加载obj对象，所以第一行只有一个Object，没有任何别的信息可以输出，因为还没有获取，点击左边小三角查看信息的时候，这时候整个script已经执行完毕了，这个时候获取到的a的值就是最终的值，就是10

     刷新之后

     ![](D:\GP-2002\笔记\img\对象引用存储2.png)

     结果的说明：再次刷新的时候，浏览器中已经有了obj的缓存，所以在第一行就会输出对象obj的相关信息，这个时候还没有去获取obj的值，仅仅是使用缓存中的值，所以第一行的时候a是1，但是点击三角获取obj信息的时候，堆中obj的a仍然是10

   + 判断对象是否相等，仅判断地址，而不是判断对象是否相等

     最简单的处理：将对象转换为json字符串，这种处理有漏洞，有可能会出错

     处理的弊端：如果一个对象里是有两个属性的，只是位置不一样而已，这样的方法就是错误的
     
     ```
     var a = {b:1}
     var a1 = {b:1}
     console.log(a===a1)
   //返回false
     ```

     #### 垃圾回收

     在堆中的对象可能会被若干个变量引用其地址，如果这个对象在后面的内容中没有被使用，我们需要将堆中的对象清除，浏览器不会自动清除

     当不断产生这种垃圾的时候，就会产生内存泄漏

     ##### 如何处理内存泄漏

     创建每个对象的管理池，针对每个对象和引用它的所有变量做统一存储管理
     
     需要清除该对象时，将引用它的所有变量设置为null，当内存上限达到峰值时，系统会通过垃圾回收机制将这些无引用的对象清除回收

3. 对象的遍历

   + for--in

     ```
     var obj = {a:1,b:2,c:3};
     for(var prop in obj){
     	console.log(prop,obj[prop]);//获取属性名和属性值
     }
     ```

     1. 对象的属性是散列的，遍历的时候是通过我们添加属性的先后顺序遍历的

     2. 对象的复制（1）

        ```
        var obj1 = {};
        for(var prop in obj){
        	obj1[prop] = obj[prop];
        }
        ```

        这时obj和obj1之间没有引用关系，但是这种对象复制是有问题的，如果obj中的属性有对象，不能完成深度遍历，只能完成广度遍历

        **误区分析**

        ```
        var obj = {
        	name: "李岚",
      	age: 18,
        	"tel": 17700000000, 
        	school:{
        		name:"southwest",
        		add:"chongqing",
        		people:{
        			dd:55
        		}
        	}
        } 
        
        console.log(obj.school);//这里可以访问到school对象
        
        var obj_new = {}
        
        for(let prop in obj){
        	obj_new[prop] = obj[prop];
        }
        
        console.log(obj_new);
        //这里可以看到看似完整复制的obj对象，包括里面的school，看似完成了深度复制，但是实际上obj_new的school中只是存储了obj.school的地址，里层是相互引用的
        
        console.log(obj_new.school.people);
        
        obj.school.add = 59;
        console.log(obj_new.school.add);
        //这里输出59，验证上面的结论，通过obj改变school中的属性值，然后查看obj_new中school的属性值，发现已经被改变，说明obj_new.school只是存储了obj中school的地址
        
        obj.age = 99;
        console.log(obj_new.age);
        //这里输出18，说明obj_new.age是独立于obj.age存在的，不受obj.age的影响
        ```
     
        
     
     3. 对象的复制（2）
     
        ```
        var obj1 = JSON.parse(JSON.stringify(obj));
        ```
     
        + 可以完成对象的深度复制，但是仍然存在很多问题：JSON的方法不可以将对象中的方法进行转换，用这种方法转换的对象方法均被忽略
        + 对象中的原型属于不可枚举属性

4. 删除对象中的属性

   ```
   var obj={a:3,b:4}
   delete obj.a;
   ```

   delete 不能删除window下的属性和方法


# 函数

### 函数基础

1. 函数是一个对象，被存储在堆中

2. 函数的创建

   + 第一种方式

     ```
     function fn1(arg1,arg2){}
     fn1();
     ```
     
+ 这种创建方式，在**script被执行的时候**，就放入堆中，并且在栈中以函数名作为变量引用堆中这个函数地址，所以可以在当前script任何位置执行对应函数
     
+ 函数在创建时就创建了函数变量，因为函数是全局的，就有可能会被别的污染覆盖，覆盖前仍然可以执行当前函数，覆盖后函数不能被执行
     
+ 如果函数中没有使用return关键字，函数返回undefined
     
  ```
       function fn1(arg1,arg2){console.log("a")}
       console.log(fn1());
       //输出a和undefined
       
       console.log(fn1);
       //会打印整个函数内容
       console.dir(fn1);
       //以对象形式打印函数
       
       支持给函数添加属性
       fn1.a = 3;
       ```
     
+ 函数本身就是一个对象，所以可以给函数添加属性，同时也具备引用关系
     
+ 第二种方式：匿名函数创建
   
  ```
     var fn2=function(){
     }
     ```
     
   + 变量什么时候定义，这个变量才能在栈中产生，才可以被调用
  + 清除的时候直接设置为null即可
     
   + 第二种方式：自执行、自调用函数，也是一种匿名函数，归为第二类

     ```
  (function(){
     	console.log("aa");
     })()
     ```
   
     + 自动执行，永远不可能调用第二次

   + 第三种方式：构造函数创建

     ```
  var fn = new Function("a","b","console.log(a+b)");
     ```
   
     + 构造函数创建，每个参数都必须是字符串，除了最后一个参数是函数的语句块以外，前面所有的参数都是该函数的参数，即参数数量不固定
  + 执行效率低下
     + 优点：所有的字符串都可以转换，可以动态接收服务端传过来的代码和参数，转换后进行执行，可以使得前端的代码不固定，通过后端动态生成

### 参数

1. 参数的作用：使得函数能够在不同情况下解决不同问题，使得函数能够处理一类问题，而不是一个

2. 在设计函数的时候，尽量不要让函数内部和外部有关联，尽量让函数内部是一个独立的个体

3. 函数不要太复杂，每个很小的功能都可以抽象出来做一个单独的函数

4. 因为js是一种弱类型语言，因此不能对函数的参数约束类型，这就会造成，因为使用者输入的参数不符合要求而造成代码出错

5. ES5版本中，js中参数不能设置初始值，不填写参数值，就默认为undefined

6. 形参和实参的定义

7. js中实参是按照形参顺序一一赋值个形参的，如果实参数量小于形参数量，后面的形参的值为undefined

8. **ES5中的arguments**

   + 当实参的数量大于形参的数量的时候，就会使用arguments，arguments的值就是传入函数的对应位置的实参，arguments只能出现在函数中，在函数中可以使用类似数组的方式使用arguments，```arguments[0]```，主要用于当前函数参数不固定的情况

     ```
     function sum(){
     	var s = 0;
     	for(var i = 0;i<arguments.length;i++) s+=arguments[i];
     	console.log(s);
     }
     s(3,4);
     s(3,4,5);
     上面几种方式均可正常使用
     ```

   + arguments中的属性

     ```
     function fn1(){
     	console.log(arguments.callee)//当前函数
     	console.log(arguments.callee.name)//当前函数的名字
     	console.log(arguments.callee.caller)//调用当前函数的外部函数，可以查看当前函数被谁调用了
     }
     ```

     callee经常用在自执行函数重复调用自身
     
   + 实参的长度小于形参的长度：```arguments.calee.length < arguments.length```
   
   + 函数的长度fn.length是指形参的长度，arguments的长度是指实参的长度

### 变量的作用域

1. 局部变量和全局变量

2. 局部变量优先：只要函数中有var定义，这个变量就一定是局部变量，并且局部优先，形参就相当于被定义好的局部变量，重复定义的局部变量（形参也是一种定义）不赋值不起作用

   ```
   var a = 5;
   function b(){
   	console.log("function    "+a);//a是undefined，局部变量优先，但是赋值在后
   	var a = 4;
   	console.log("function    "+a);//a是4
   	
       // console.log(a+window.a);ES6中完全禁止
   }
   b();
   console.log(a);//a=5没有被b函数修改
   ```

   + 函数都会被优先解释和编译，跟书写位置没有关系

   ```
   var a;
   function a(a){
   	console.log(a);
   	var a;
   	console.log(a);
   	a = 10;
   	console.log(a);
   }
   a(6);//可以执行
   a = 100;
   a(6);//报错
   ```

   + 面试题1

     函数中的局部变量不会向下传递，在函数中调用函数，不会将当前函数的局部变量传递到当前函数调用的函数中

   ```
   var x = 10
   function fn() {
   	console.log(x)
   }
   function show(f) {
   	var x = 20
   	f()
   }
   show(fn) 
   //10
   ```

   + 面试题2

     只要变量在函数当中有声明了，就会把声明提到最前面，不管这个声明在什么位置上，就算是在分支和循环中，也会提到最前面

   ```
   var name = 'World!';
   (function () {
   	if (typeof name === 'undefined') {
   		var name = 'Jack'
   		console.log(name)
   	} else {
   		console.log(name)
   	}
   })()
   
   //输出Jack
   ```
   
   + 错题1
   
   ```
   var num1=1;  
   function testf1(){
   	num1=2;  
   	alert(num1);
   }
   function testf2(){ 
   	alert(num1); 
   }   
   testf1();  
   testf2();
   //输出结果为2,2
   ```
   
   原因：在运行testf1的时候，因为没有定义局部变量，所以去找num1的全局变量，将全局变量改为2，所以后面再访问全局变量的时候，num1的值为2

### let关键字

1. 使用let关键字的原因：

   + var定义的变量没有块作用域
   + var定义的全局变量会自动添加为window对象的属性
   + var定义的变量会提前装载

2. 循环体中使用let定义的i只在循环体中有效，使用var定义有效期会延迟到循环体外面

   ```
   for( let i = 0;i<10;i++){
   	console.log(i);
   }
   console.log("循环体之外" + i);//报错
   ```

3. var定义的变量会提前装载，但是let定义的变量要等到程序流执行到定义变量的代码的时候才会加载

### return

1. 函数在执行时将返回函数中return的内容，没有return或者return后面没有内容，会返回undefined

2. 函数执行是阻断式的，函数中调用了其他函数，里面的函数执行外才会执行下面的代码，当需要并列执行多个时，我们可以在一个函数中统一调配执行

3. 函数返回的作用：

   + 对象具有引用关系

   + 改变引用类型的时候，不需要返回**灵活辨别**

   + return可用于跳出切断，中断执行流程，注意break和return的灵活应用，比如在较为单一的switch中，有return就可以不使用break

   + 如果if分支循环中判断的条件非常多，可以使用switch的穿越

     ```
     function fn(a,b,type){
     	if(type !== "+" || type !== "-" || type !== "*" || type !== "/")
     	
     可以写成
     switch(type){
     	case "+":
     	case "-":
     	case "*":
     	case "/":break;
     	default:return;
     	}
     }
     ```

   + eg

     ```
     function fn(){
     	return function(){
     		console.log("aa");
     	}
     }
     var f = fn();
     f():
     ```

     

# 函数进阶

### 回调函数

1. 定义：将一个函数以参数的形式传入到另一个函数中，并在那个函数中执行，这样叫做回调

   ```
   function fn1(fn){
   	fn();
   }
   function fn2(){
   	cosole.log("aaa");
   }
   fn1(fn2);
   ```

2. 应用：

   + 回调一般用于当处理某件事情需要等待时，设置回调，下面的两个方法均是回调的应用

   + 当不需要关心具体后续需要处理的事情时，设置回调

     类似游戏插槽，主机并不关心是什么游戏，插什么卡，处理什么游戏

     ```
     function setLight(){
     	arguments[0]();
     	arguments[1]();
     	arguments[2]();
     }
     function redLight(){
     	console.log("红灯");
     }
     function yellowLight(){
     	console.log("黄灯");
     }
     function greenLight(){
     	console.log("绿灯");
     }
     setLight(redLight,yellowLight,greenLight);
     
     ```

   ###### 两个方法

   1. setTimeout(超时执行的函数，超时时间，执行函数的参数)    返回一个ID数    异步执行

      ```
      var id = setTimeout(fn,2000,5)
      
      console.log("a")
      function fn(n){
      	console.log(n);
      	clearTimeout(id);//清除时间间隔，清除这个超时函数
      }
      console.log("b");
      console.log(id);
      //打印a和b，过两秒（2000ms）打印出5
      ```

   2. setInterval(执行函数，间隔时间)，每过一段时间，就执行fn函数

      ```
      var id = setInterval(fn,2000)
      var num = 0;
      function fn(){
      	num++;
      	console.log("aa");
      	if(num>5) clearInterval(id);
      }
      ```

   ###### 案例1 红绿灯 

   + 利用回调，将异步变成同步等待，异步时如何处理一个接一个的问题

   ###### 案例2 累加

   + 使用回调的时候要注意return到了哪里

### 递归函数

1. 函数内部执行自身，叫做递归

   ```
   var i = 0;
   function fn1(){
   	i++;
   	if(i<3) fn1();
   	console.log(i);
   }
   fn1();
   //输出3 3 3
   ```

   递归的层数不能太多，会造成堆栈上限溢出，根据内存大小，递归次数的上限也不一样

### 函数的声明

1. 普通函数声明

2. 匿名函数声明（1）

   ```
   var box=function(num1,num2){
          retrun num1+num2;
   }
   ```

   匿名函数声明（2）

   ```
   var obj={
   	name:”zhangsan”,
   	fire:function(num1,num2){
   	        var s=num1+num2;
   		return s;
   	}
   }
   ```

4. Function构造函数

### 工厂型创建对象

### 函数的执行

### 函数的删除

+ 只有函数是匿名定义的或者通过构造函数创建的才可以被删除

1. 匿名函数删除：函数=null
2. 对象下的方法删除： delete obj.fn;

### 函数对象

1. 函数也是一个对象，可以为他定义属性和方法
2. 如果要执行函数使用fun1()，但是要调用函数的方法或者属性的时候，就不能加小括号了，因为fun1才是对象，加上小括号是获取执行结果
3. 函数也是对象，每个对象都包含两个属性：length和prototype，其中length表示函数希望接收的命名参数的个数

### 内存管理



# 构造函数

### 构造函数

1. 通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性。
2. 原型内方法地址是否一样？？
3. 

### 实例化对象

### 原型对象



# 数组

1. 数组和对象

   + 数组
     + 有序的列表存储若干个无序的元素，紧凑型结构
     + 删除一个元素时，后面的元素就向前递进
     + 数组有长度arr.length
     + 插入和删除都会影响数组的位置和结构，因此数组的运行效率时间复杂度较高
     + 存储依靠下标，如果需要查找一个元素，需要遍历数组的每个元素
     + 数据的关联性比较强，比如排好序的数组，可以轻易查找比特定元素大（小）的值

   + 对象
     + 是一种松散型结构，对象的属性是键值存储
     + 删除一个元素时，对象的其他值不会发生变化
     + 对象没有长度，没有obj.length
     + 插入和删除不会影响其他数据，因此对象的时间复杂度极低
     + 对象是通过键值对存储，获取时只需要根据key去获取即可
     + 数据关联性比较弱，数据独立存在，不能排序，不能查找关联关系对应的值

2. 数组的元素简称元，访问方式arr[index]，这种方式叫做下标变量

### 创建数组

1. JavaScript是弱类型，数组中可以同时存储各种类型的数据，但是运行效率极低，数组存储时要注意考虑数组的用途和数据类型

2. 数组可以任意扩张，不需要限定长度

3. 创建数组的方式

   + 字面量创建数组```var arr = [1,2,3]```
   + 构造函数创建数组```var arr = new Array(1,2,3)```
     1. 缺点：构造函数创建数组时只有一个自然数参数，则这个参数代表数组的长度，数组为空，如果是负数或者小数，就会报错。如果是非数值，就会作为数组中的第一个元素
   + 对象创建法```var arr = new Object([]);```

4. ```typeof arr```会输出object，区分数组和对象的方法：

   + ```console.log(arr.constructor === Array)```，最保险
   + ```console.log.lig(Array.isArray(arr))```，ES6以后支持
   + ```console.log(String(arr) !== "[object object]")```，对象转换为字符串是```[object Object]```，数组转换为字符串时，都会转换为数组的元素连接成的字符串

5. 数组也是对象，也是引用地址赋值

   ```
   console.log([] === []);  //false
   console.log([] == []);   //false
   
   console.log(![] == []);  //true
   左右两边类型不一样，数组会转换为字符串
   左边：
   ![] ---->  false  还没进行比较，只是!，所以不会转换为字符串，[]也是对象，对象转换为布尔值是true，！就是false
   右边：
   [] ---->  "" ---->  false
   
   [] ~ ""、false、0 ----> true
   ```


6. 数组在强转或者隐式转换为字符串时，都会转换为数组的元素连接成的字符串



### 数组的属性

1. arr.length

   + 可读可写

   + 如果设置的length比原本数组的长度小，那么就会删除尾部的元素

   + ```arr.length = 0;```清空数组中所有元素

   + 如果设置的length比原本数组的长度大，那么就会在尾部添加空元素

   + 在数组尾部添加一个元素```arr[arr.length] = 5;```

   + 数组下标大于数组的长度时，对应下标增加元素，中间增加空元素（空元素输出undefined）

   + 数组元素为undefined和空元素```arr[i] === undefined```都是true

   + 数组使用for循环遍历，使用下标遍历，不遍历数组点语法添加的属性，但是会遍历到空元素，遍历时下标都是数值

     数组使用for-in循环遍历，会遍历所有的可枚举属性，没有值就不遍历，遍历时下标都是字符串

### 数组的方法

### 数组的遍历

### 函数中的call和apply

### 函数的绑定

### arguements对象

### 二维数组

### 对象数组



