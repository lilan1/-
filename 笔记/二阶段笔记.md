# 语言基础

1. JavaScript历史

2. JavaScript组成

   核心（ECMAScript）

   文档对象模型（DOM）（html标签）

   浏览器对象模型（BOM）

3. JavaScript引入及写法

   + 内部书写

     + 位于head部分的脚本

       全部的JavaScript代码都被下载、解析和执行完成之后，才能开始呈现页面的内容，浏览器在遇到body标签才开始呈现内容

     + 位于body部分的脚本，不推荐将js语句放在HTML标签中

       优点：解决了上面的问题

   + 外部引入（推荐），head和body均可以```<script src="./a.js"></script>```，**添加目录的时候一定要加"./"，尽量不使用"../"，禁止使用绝对路径，也可以使用网络地址**

     优点：

     + 可维护性
     + 可缓存
     + 适应未来：通过使用外部文件包含JavaScript代码，无需使用XHTML或注释hack

     1.  如果加载的js中，变量或者函数相同的时候，就会覆盖，这种情况叫做变量污染

   + 直接写在行内

   + ES6的代码引入和写法

   1. 从上向下解释性文档，上面的代码无法调用下面的标签和脚本
   2. 浏览器的自动纠正，script脚本放在HTML标签外面的时候，浏览器会将script标签放在body的最下面，**可利用**，但是不建议，因为会消耗浏览器的性能

4. 注释

   + 单行注释，双斜杠//
   + 块注释/**/，可以用来注释一行中的部分代码

   1. 工作的时候，不用的代码不要删除，注释掉
   2. 自己写的代码要写注释

5. 调试，F12断点调试

   + preformance，录制操作占用内存
   + memory，记录操作快照，展示内存具体使用信息

6. js语言基本标准

   + 分号结尾，英文半角
   + 大小写严格
     + 一般首字母都是小写，除了类
     + 一般都是驼峰命名规则
   + 提示信息```alert(message?:any:void)```含义：message指参数名称（_default表示默认值，...text表示可以有多个），？可以写值也可以不写，:any返回值类型任意，:void表示不返回值

7. 常用方法

   + console.log()
   + alert()    弹出框
   + confirm()    确认消息框
   + prompt()    提示消息框，给用户提供输入窗口

8. 语句块，通常来说，用大括号包裹的一组JavaScript语句称为语句块

9. 变量

   + JavaScript关键字
   	```txt
     break  do  instanceof  typeof  case  else  new  var  catch  finally  return  void  continue  for  switch  while  function  this  with  default  if  throw  delete  in  try
     ```
     
   + JavaScript保留字，使用保留字命名不报错，但是不能使用

     ```txt
     abstract  int  short  boolean  export  interface    static  byte  extends  long  super  char  final  native  class  float  throws  const  goto  private  double  import  public
     ```
     
   + JavaScript变量

     + ES5，IE8时代支持的js标准，ES6 2015开始正式使用，又称为ES2015

     + JavaScript的变量是松散类型的，所谓的松散类型就是可以用来保存任何类型的数据

     + 不推荐创建全局变量，污染全局命名空间

     + 定义未初始化的值：undefined

     + 一条语句定义多个变量，逗号分隔

     + =赋值也是有返回值的，返回等号右边的值

     + 连等赋值，a=b=3，先赋值给a，再赋值给b，运行过程是先将（b=3）的返回值赋值给a，再将3赋值给b，任何赋值都是有返回值的

     + ES5中不允许直接使用变量的赋值，必须前面加一个var声明变量的赋值

     + 如果不使用var声明，name这个变量就一定从属于window，而在函数以外的地方使用var声明，也是设置了window的属性，也从属于window

     + 变量的命名规则：

       1. 驼峰式命名
       2. 临时变量必须使用下划线起头后面接驼峰式命名，有时候也会在函数的参数中使用临时变量
       3. 全局的变量名不能与window下的属性和方法同名，不报错，但是会覆盖本来的函数
       
     + window下的变量status固定为字符串，使用代码提示检测变量名是否是关键字
     
     + const常量，常量名称必须大写，并且使用下划线区分单词
     
       使用常量的目的是，不会被别人修改或者变量污染
   
10. 数据类型

      + 字符串（string），反引号，双引号，单引号

      + 数字（number），各类进制（log会打印十进制）、整数、浮点数、带符号，科学计数法，布尔（boolean），数值型变量没有引用关系

      + NULL

        + typeof输出object

          原因：因为null多用于对象清空，字符类型、数值类型、布尔类型、未定义数据类型均不需要使用null进行回收

        + 空值是将所有引用地址标记清空，用于清理内存，垃圾回收

      + Undefined

        + 仅定义未初始化
    + 声明变量并初始化为undefined
        + 函数没有返回值时，默认返回undefined
    
        1. ```var b = undefined;```，一般用于将原有值的变量设置为undeifned 

      + 对象
    
        1. 无序键值对
        
           ```
           var d="add";
           var obj={
           	name:"李岚",
           	age:18,
           	"tel":17700000000,    //不建议
           	[d]:"天津市"    //变量作为key必须在外层增加中括号
           }
           console.log(obj[d]);    //调用变量作为key的属性
           console.log(obj["name"]);
           console.log(obj.age);
           ```
        
        2. ```
           var obj={};
           含义是空对象，盒子为空
           
           obj=null;
           含义是空，盒子都扔了
           ```
        
        3. 对象中不能出现重复的属性
    
      1. typeof操作符用来检测变量的数据类型，是个操作符，不是函数
  2. JavaScript不支持任何创建自定义类型的机制
    
11. 数据类型转换

       1. 数值转换

          + 数字转换为字符串

            1.   

               ```
               var a = 3;
               var b = String(a);
               ```

            2. 隐式转换（依据运算特征）

               ```
               a = a + "";
               自动执行String(a)方法，然后进行相加
               ```

            3. toString(number)

               实际上是对象的方法，万物皆对象，所有的变量都有该方法

               toString()方法的参数必须是2-36之间的整数，表示进制，转换为特定的进制数值

               ```
               var a = 15;
               a = a.toString(16);
               console.log(a);
               此时输出F
               ```

            4. toFixed(number)

               参数为浮点位，表示小数点后面保存的位数，15~15.00，自动四舍五入

               a = a.toFixed(2)

            5. toExponential()

               + 将数值格式化为科学计数法
               + 参数值的范围是0~20
               + 参数值表示科学计数法小数点后面的位数，当数值的位数超出参数指定范围的时候，进行四舍五入

            6. toPrecision()

               + 将数值格式化为指定的长度，参数字、表示长度
               + 当对象的值超出指定位数时，将其格式化为科学计数法，不够的时候用小数点后面的0来凑

          + 数值转换为布尔值

            1. 只有0转换成布尔值是false

            2. 强制转换（只能Boolean()强制转换）

               ```
               var a = 0;
               a = Boolean(a);
               console.log(a);
               //false
               ```

          + 数值转换为对象---->数值型对象

            1. Object()

               ```
               var a = 0;
               a = Object(a);
               console.log(a);
               输出为0
               typeof a//输出为Object
               ```

               数值型对象可以加减，具有数值特征，存储在堆中

       2. 字符串转换

          + 字符串转换为数值

            1. Number()

               ```
               var a = "a";
               a = Number(a);
               console.log(a);
               输出NaN
               //NaN，数值类型中的非数值
               如果是字符串本身就是数值的，则可以正常转换
               ```

            2. parselnt()    

               + 字符串转换成整数

               + 两个参数，第一个参数是需要转换的值，第二个参数表示按照几进制接收

                 ```
                 var a = "101";
                 a = parseInt(a,2);
                 //此时输出a为5
                 ```

            3. parseFloat()    字符串转换成浮点数，不能转换进制

            4. 注意：

               + 后面两个函数在转换"32a"这种的时候会转换成32，省略不符合数值特征的部分，而Number会报错，隐式转换遵从Number

               + Number的转换，"32 "(32+空格)，--->32，"32 1"---->NaN，首尾有空格会自动去除，但是中间有不可以，会被认定为字符，但是后面两个函数会省略中间空格后面的内容进行数制转换

          + 字符串转换为布尔值    Boolean()

            1. 仅空字符串转换为布尔值时，被认定为false，除此之外全部是true
            2. 空格不是空字符串，空格是true

          + 字符串转换为对象    Object()    转换后为字符串对象

       3. 布尔值转换

          + 布尔值转换为数值，true转换为1，false转换为0
          + 布尔值转换为字符
          + 布尔值转换为对象，转换后为布尔对象
          + 任何类型转换为布尔值
            1. false：空字符串、0，NaN、false、null、undefined
            2. 除了上面六种情况均为true

       4. undefined、null转换为字符串和数值

          + 字符串转换结果为字符串的undefined和null
          + 转换为数值Number转换结果为undefined--->NaN，null--->0
          + 转换为数值parseInt转换结果为undefined--->NaN，null--->NaN

          注意：

          1. 数据类型转换分为强制转换和隐式转换

          2. 字符串方法trim()

             ```
             var a = "   li lan  ";
             a = a.trim();
             清除字符串前后空格，中间不管
             ```

12. 定义变量的常用方法

    + 尽量不要使用连等赋值变量定义
    + 有值变量定义最好换行定义，按照类型定义，将类型分开定义，比较清楚

14. 运算符
    + 算术运算符：加减乘除、取模%

        1. “+”号两端出现字符串的话，就会变成字符串拼接，数值、布尔值、undefined、Null通过String隐式转换为字符串

        2. “+”号两端没有出现字符串，其他非数值类型就会转换为数值并相加

        3. 所有类型遇到“-”、“*”、“/”和“%”的时候，都会隐式转换为数值进行运算

        4. 浮点运算存在误差

        5. 加法运算符结果

           ![](D:\GP-2002\笔记\img\加法运算符.png)

    + 一元运算符：累加++、递减--

        1. ++a和a++

           累加（递减）在前，先返回后运算，以+1后的结果参加运算

           累加（递减）在后，先运算后返回，以a参加运算，+1前

        2. 对于累加和递减，通常都会直接使用算数运算来处理

           会先将内容隐式转换为数值，然后再运算

           ```
           var a = "3";
           var b = a++;
           //b输出结果为数值3
           将字符串隐式转换为数值的一种方式
           
           这种恶心吧啦的式子随便拆
           b=a+++a+++a+a+++a+a
       b=a+++(a=a+a)+a++*2
          ```

           

    + 关系运算符：大于、大于等于、小于、小于等于、等于、严格相等、不等、非严格相等

       1. 关系运算符尽可能使用三个等号，判断更严谨

          ```
          console.log(""==false);
          console.log(0=="");
          console.log(0==false);
          上面全是true
          
          下面是false
          console.log(0==null);
          
          独立相等，返回true，且不与""、0、false相等，这三个彼此相等
          console.log(undefined==null);
          
          特殊：NaN，NaN跟任何值都不相等，包括他自身，NaN==NaN-->false
       判断NaN，使用isNaN(a)
          ```
          
          ```
          var a = 0;
                 if (a == false){
                 	console.log("aa");
                 	//a--> 0 false
                 }
                 if (a === false){
                 	console.log("aa");
                 	//a-->false
                 }
                 if (!a){
                 	console.log("aa");
                 	//a--> 0  null  false  undefined  ""  NaN
                 }
                 if (a == null){
                 	console.log("aa");
                 	//a--> undefined  null
                 }
                 if (a === undefined){
              	console.log("aa");
                 	//a--> undefined
            }
          ```
          
          **不同数据类型之间的“==”抽象相等比较**
          
          number的优先级最高，所有的类型都尽量转换为number进行处理
       
    + 逻辑运算符：逻辑非！、逻辑与&&、逻辑或||

       1. 得到的结果不一定是布尔值

          + 第一个值  &&  第二个值

            当第一个值为假，结果为第二个值；第一个值为真，结果为第一个值

          + 第一个值  ||  第二个值

            当第一个值为假，结果为第二个值；第一个值为真，结果为第一个值
            
            ```
            var obj = {a:2};
            obj = obj || {a:1}
            console.log(obj);
            如果obj转换为布尔值是false，直接熔断
            ```

       2. 逻辑非可以用来做开关、多选框的反选

    + 赋值运算符（运算符优先级低）：

      1. 乘法/赋值（*=）

      2. 除法/赋值（/=）

      3. 取模/赋值（%=）

      4. 加法/赋值（+=）

         ```a+=""```，将a隐式转换为字符串

      5. 减法/赋值（-=）

      6. 左移/赋值（<<=），二进制移位

      7. 有符号右移/赋值（>>=）

      8. 无符号右移/赋值（>>>=）

    + 位运算符

       1. 位非运算符（~）    加1取负
       2. 位与运算符（&）
       3. 位或运算符（|）
       4. 位异或运算符（^） 同0异1  
       5. 左移位运算符（<<）
       6. 右移位运算符（>>）

    + 条件运算表达式

       1. 条件语句 ？ 语句1 ：语句2;

          判断条件是否成立，成立执行语句1，不成立执行语句2

       + 三目运算符优先级比赋值运算符高
       + 当返回的是布尔值的时候，不要使用三目运算符
       + 问号前面的内容会隐式转换为布尔值
       + 不要将条件运算表达式复杂化，尽量不要使用赋值运算符

15. 运算符优先级
    + 赋值运算符的优先级最低
    + 一元运算符优先级很高，比乘除高
    + 强制优先级：加括号

16. 表达式

# 流程控制语句

### 条件语句

1. 只有一条语句的时候，可以不加大括号

   ```
   if(){
   }
   ```

   ```
   if(){
   }else{
   }
   ```

   ```
   if(){
   }else if{
   }else if{
   }else{
   }
   ```

2. switch case

   ```
   switch(表达式)
   {
   	case 值1:
   		语句1;
   		break;
   	case 值2:
   		语句2;
   		break;
   	default:
   		语句3;
   }
   ```

   + 表达式和值1必须是严格相等才会执行语句1，值也可以是运算式
   + break是必须的，如果值1没有break，程序不会判断表达式是否与值2严格相等，直接执行语句2，这种现象叫做穿越
   + 穿越现象会被利用减少代码量，减少重复代码
   + switch经常会被用来做状态机
   + 特点：严格相等、判决条件清晰、可穿越

3. 条件不管是什么表达式，都会隐式转换为布尔值

4. 常用运算符：非！（非真进入）

### 循环语句

+ 禁止出现重复代码
+ 要将代码尽可能进行加精简

1. while    先判断后循环，循环体有可能一次也不执行，循环体应包含使循环结束的语句

   ```
   while（判断语句）｛
   	循环体；
   ｝
   ```

   + 在大量运行时，while的效率高于for，推荐使用while

2. do while    先运行后判断，至少运行一次

   ```
   do
   {
      循环体;    
      循环增量;
   }while(循环条件)
   ```

   + 常使用++i
   + 使用场景较少

3. for

   ```
   for(var i=0;i<10;i++){
   	console.log(i)
   }
   ```

   ```
   var i = 0,sum = 0;
   for(i = 0;i++ < 100;sum += i);
   ```

    + ```for(语句1;语句2;语句3){}```
       语句3所在位置的语句块的含义是，一次循环执行完毕之后一定会要执行的语句，不一定是变量不断变化的语句
       
    + 典型的死循环
      
       ```
       for(;;){
       }
       ```
4. for-in**待补充**
5. for-each**待补充**
6. for-of**待补充**
7. map循环**待补充**

+ 使用循环的时候，一定要尽可能避免循环定义变量
+ 使用循环的时候，一定要注意临界值
+ 在双重循环的时候，不要在内层中判断外层变量或者改变外层变量
+ 循环条件均会隐式转换为布尔值
+ 如果使用break的时候，不写跳出label的时候，它只会跳出当前循环
+ 循环是同步的，循环的总次数不要超过亿，嵌套的更要注意
+ 六种循环中while相对来说效率比较高，递归循环的时间复杂度最低
+ ```document.body.innerHTML = str```会将body内原本的内容替换掉，将等号换成 += 就可以了

### break    

1. 可以跳转到指定的ID位置

### continue    

1. 处理循环中阶段性不符合条件的时候，可以使用continue
2. 支持跳转ID

# 对象

### 类和对象的概念

### 对象创建

1. var obj=new Object();
2. var obj={}
3. var obj=Object.creat({});**自己补充**

### 对象的属性和方法

1. 对象基础

   ```
   var d="add";
   var obj={
   	name:"李岚",
   	age:18,
   	"tel":17700000000,    //不建议
   	[d]:"天津市",   //变量作为key必须在外层增加中括号
   	9:10
   }
   console.log(obj[d]);    //调用变量作为key的属性
   console.log(obj["name"]);
   console.log(obj.age);
   console.log(obj.9);    //点语法拒绝使用非字符类型属性
   console.log([9]);  //在对象中key除了字符类型以外只能支持symbol类型，数值会被隐式转换为字符
   ```
    + 对象的属性必须是字符串，否则不能使用点语法来获取
    + 点语法只能获取属性名明确的字符串属性
   ```
   var d = "add";
   var obj = {
   	name: "李岚",
   	age: 18,
   	"tel": 17700000000,    //不建议
   	[d]: "天津市"   //变量作为key必须在外层增加中括号
   }
   	
   var a = {
   	aa : 30
   }
   var b = {
   	bb:70
   }
   var arr = [1,2,3]
   var arr1 = [4,5,6]
   obj[undefined] = 10;
   obj[null] = 20;
   obj[a] = 50;
   obj[b] = 60;  //对象都会转换为[Object Object]，所以会覆盖前面的，但是数组不会覆盖
   obj[arr] = 100;
   obj[arr1] = 110;
   
   console.log(obj[undefined]);
   console.log(obj[null]);
   console.log(obj[a]);
   console.log(obj);
   ```

   运行结果

   ![](D:\GP-2002\笔记\img\对象运行结果.png)

2. 对象引用存储

   + 堆~存储空间，

     栈~临时存储，栈中存储堆中内容的地址

     ```
     var obj = {
     	a:1
     }
     console.log(obj);
     obj.a = 10;
     ```

     第一次运行结果

     ![](D:\GP-2002\笔记\img\对象引用存储1.png)

     结果说明：第一次运行，在浏览器缓存中没有关于obj对象的缓存，在点击左上角的小三角的去获取a的值的时候，整个浏览器才会去堆中加载obj对象，所以第一行只有一个Object，没有任何别的信息可以输出，因为还没有获取，点击左边小三角查看信息的时候，这时候整个script已经执行完毕了，这个时候获取到的a的值就是最终的值，就是10

     刷新之后

     ![](D:\GP-2002\笔记\img\对象引用存储2.png)

     结果的说明：再次刷新的时候，浏览器中已经有了obj的缓存，所以在第一行就会输出对象obj的相关信息，这个时候还没有去获取obj的值，仅仅是使用缓存中的值，所以第一行的时候a是1，但是点击三角获取obj信息的时候，堆中obj的a仍然是10

   + 判断对象是否相等，仅判断地址，而不是判断对象是否相等

     最简单的处理：将对象转换为json字符串，这种处理有漏洞，有可能会出错

     处理的弊端：如果一个对象里是有两个属性的，只是位置不一样而已，这样的方法就是错误的
     
     ```
     var a = {b:1}
     var a1 = {b:1}
     console.log(a===a1)
   //返回false
     ```

     #### 垃圾回收

     在堆中的对象可能会被若干个变量引用其地址，如果这个对象在后面的内容中没有被使用，我们需要将堆中的对象清除，浏览器不会自动清除

     当不断产生这种垃圾的时候，就会产生内存泄漏

     ##### 如何处理内存泄漏

     创建每个对象的管理池，针对每个对象和引用它的所有变量做统一存储管理
     
     需要清除该对象时，将引用它的所有变量设置为null，当内存上限达到峰值时，系统会通过垃圾回收机制将这些无引用的对象清除回收

3. 对象的遍历

   + for--in

     ```
     var obj = {a:1,b:2,c:3};
     for(var prop in obj){
     	console.log(prop,obj[prop]);//获取属性名和属性值
     }
     ```

     1. 对象的属性是散列的，遍历的时候是通过我们添加属性的先后顺序遍历的

     2. 对象的复制（1）

        ```
        var obj1 = {};
        for(var prop in obj){
        	obj1[prop] = obj[prop];
        }
        ```

        这时obj和obj1之间没有引用关系，但是这种对象复制是有问题的，如果obj中的属性有对象，不能完成深度遍历，只能完成广度遍历

        **误区分析**

        ```
        var obj = {
        	name: "李岚",
      	age: 18,
        	"tel": 17700000000, 
        	school:{
        		name:"southwest",
        		add:"chongqing",
        		people:{
        			dd:55
        		}
        	}
        } 
        
        console.log(obj.school);//这里可以访问到school对象
        
        var obj_new = {}
        
        for(let prop in obj){
        	obj_new[prop] = obj[prop];
        }
        
        console.log(obj_new);
        //这里可以看到看似完整复制的obj对象，包括里面的school，看似完成了深度复制，但是实际上obj_new的school中只是存储了obj.school的地址，里层是相互引用的
        
        console.log(obj_new.school.people);
        
        obj.school.add = 59;
        console.log(obj_new.school.add);
        //这里输出59，验证上面的结论，通过obj改变school中的属性值，然后查看obj_new中school的属性值，发现已经被改变，说明obj_new.school只是存储了obj中school的地址
        
        obj.age = 99;
        console.log(obj_new.age);
        //这里输出18，说明obj_new.age是独立于obj.age存在的，不受obj.age的影响
        ```
     
        
     
     3. 对象的复制（2）
     
        ```
        var obj1 = JSON.parse(JSON.stringify(obj));
        ```
     
        + 可以完成对象的深度复制，但是仍然存在很多问题：JSON的方法不可以将对象中的方法进行转换，用这种方法转换的对象方法均被忽略
        + 对象中的原型属于不可枚举属性

4. 删除对象中的属性

   ```
   var obj={a:3,b:4}
   delete obj.a;
   ```

   delete 不能删除window下的属性和方法


# 函数

### 函数基础

1. 函数是一个对象，被存储在堆中

2. 函数的创建

   + 第一种方式

     ```
     function fn1(arg1,arg2){}
     fn1();
     ```
     
     + 这种创建方式，在**script被执行的时候**，就放入堆中，并且在栈中以函数名作为变量引用堆中这个函数地址，所以可以在当前script任何位置执行对应函数
     
     + 函数在创建时就创建了函数变量，因为函数是全局的，就有可能会被别的污染覆盖，覆盖前仍然可以执行当前函数，覆盖后函数不能被执行
     
     + 如果函数中没有使用return关键字，函数返回undefined
     
       ```
       function fn1(arg1,arg2){console.log("a")}
       console.log(fn1());
       //输出a和undefined
            
       console.log(fn1);
       //会打印整个函数内容
       console.dir(fn1);
       //以对象形式打印函数
            
       支持给函数添加属性
       fn1.a = 3;
       ```
     
     + 函数本身就是一个对象，所以可以给函数添加属性，同时也具备引用关系

   + 第二种方式：匿名函数创建

     ```
     var fn2=function(){}
     ```

     + 变量什么时候定义，这个变量才能在栈中产生，才可以被调用
     + 清除的时候直接设置为null即可

   + 第二种方式：自执行、自调用函数，也是一种匿名函数，归为第二类

     ```
     (function(){
     	console.log("aa");
     })()
     ```

     + 自动执行，永远不可能调用第二次

   + 第三种方式：构造函数创建

     ```
     var fn = new Function("a","b","console.log(a+b)");
     ```

     + 构造函数创建，每个参数都必须是字符串，除了最后一个参数是函数的语句块以外，前面所有的参数都是该函数的参数，即参数数量不固定

     + 执行效率低下

       优点：所有的字符串都可以转换，可以动态接收服务端传过来的代码和参数，转换后进行执行，可以使得前端的代码不固定，通过后端动态生成

### 参数

1. 参数的作用：使得函数能够在不同情况下解决不同问题，使得函数能够处理一类问题，而不是一个

2. 在设计函数的时候，尽量不要让函数内部和外部有关联，尽量让函数内部是一个独立的个体

3. 函数不要太复杂，每个很小的功能都可以抽象出来做一个单独的函数

4. 因为js是一种弱类型语言，因此不能对函数的参数约束类型，这就会造成，因为使用者输入的参数不符合要求而造成代码出错

5. ES5版本中，js中参数不能设置初始值，不填写参数值，就默认为undefined

6. 形参和实参的定义

7. js中实参是按照形参顺序一一赋值个形参的，如果实参数量小于形参数量，后面的形参的值为undefined

8. **ES5中的arguments**

   + 当实参的数量大于形参的数量的时候，就会使用arguments，arguments的值就是传入函数的对应位置的实参，arguments只能出现在函数中，在函数中可以使用类似数组的方式使用arguments，```arguments[0]```，主要用于当前函数参数不固定的情况

     ```
     function sum(){
     	var s = 0;
     	for(var i = 0;i<arguments.length;i++) s+=arguments[i];
     	console.log(s);
     }
     s(3,4);
     s(3,4,5);
     上面几种方式均可正常使用
     ```

   + arguments中的属性

     ```
     function fn1(){
     	console.log(arguments.callee)//当前函数
     	console.log(arguments.callee.name)//当前函数的名字
     	console.log(arguments.callee.caller)//调用当前函数的外部函数，可以查看当前函数被谁调用了
     }
     ```

     callee经常用在自执行函数重复调用自身
     
   + 实参的长度小于形参的长度：```arguments.calee.length < arguments.length```
   
   + 函数的长度fn.length是指形参的长度，arguments的长度是指实参的长度

### 变量的作用域

1. 局部变量和全局变量

2. 局部变量优先：只要函数中有var定义，这个变量就一定是局部变量，并且局部优先，形参就相当于被定义好的局部变量，重复定义的局部变量（形参也是一种定义）不赋值不起作用

   ```
   var a = 5;
   function b(){
   	console.log("function    "+a);//a是undefined，局部变量优先，但是赋值在后
   	var a = 4;
   	console.log("function    "+a);//a是4
   	
       // console.log(a+window.a);ES6中完全禁止
   }
   b();
   console.log(a);//a=5没有被b函数修改
   ```

   + 函数都会被优先解释和编译，跟书写位置没有关系

   ```
   var a;
   function a(a){
   	console.log(a);
   	var a;
   	console.log(a);
   	a = 10;
   	console.log(a);
   }
   a(6);//可以执行
   a = 100;
   a(6);//报错
   ```

   + 面试题1

     函数中的局部变量不会向下传递，在函数中调用函数，不会将当前函数的局部变量传递到当前函数调用的函数中

   ```
   var x = 10
   function fn() {
   	console.log(x)
   }
   function show(f) {
   	var x = 20
   	f()
   }
   show(fn) 
   //10
   ```

   + 面试题2

     只要变量在函数当中有声明了，就会把声明提到最前面，不管这个声明在什么位置上，就算是在分支和循环中，也会提到最前面

   ```
   var name = 'World!';
   (function () {
   	if (typeof name === 'undefined') {
   		var name = 'Jack'
   		console.log(name)
   	} else {
   		console.log(name)
   	}
   })()
   
   //输出Jack
   ```
   
   + 错题1
   
   ```
   var num1=1;  
   function testf1(){
   	num1=2;  
   	alert(num1);
   }
   function testf2(){ 
   	alert(num1); 
   }   
   testf1();  
   testf2();
   //输出结果为2,2
   ```
   
   原因：在运行testf1的时候，因为没有定义局部变量，所以去找num1的全局变量，将全局变量改为2，所以后面再访问全局变量的时候，num1的值为2

### let关键字

1. 使用let关键字的原因：

   + var定义的变量没有块作用域
   + var定义的全局变量会自动添加为window对象的属性
   + var定义的变量会提前装载

2. 循环体中使用let定义的i只在循环体中有效，使用var定义有效期会延迟到循环体外面

   ```
   for( let i = 0;i<10;i++){
   	console.log(i);
   }
   console.log("循环体之外" + i);//报错
   ```

3. var定义的变量会提前装载，但是let定义的变量要等到程序流执行到定义变量的代码的时候才会加载

### return

1. 函数在执行时将返回函数中return的内容，没有return或者return后面没有内容，会返回undefined

2. 函数执行是阻断式的，函数中调用了其他函数，里面的函数执行外才会执行下面的代码，当需要并列执行多个时，我们可以在一个函数中统一调配执行

3. 函数返回的作用：

   + 对象具有引用关系

   + 改变引用类型的时候，不需要返回**灵活辨别**

   + return可用于跳出切断，中断执行流程，注意break和return的灵活应用，比如在较为单一的switch中，有return就可以不使用break

   + 如果if分支循环中判断的条件非常多，可以使用switch的穿越

     ```
     function fn(a,b,type){
     	if(type !== "+" || type !== "-" || type !== "*" || type !== "/")
     	
     可以写成
     switch(type){
     	case "+":
     	case "-":
     	case "*":
     	case "/":break;
     	default:return;
     	}
     }
     ```

   + eg

     ```
     function fn(){
     	return function(){
     		console.log("aa");
     	}
     }
     var f = fn();
     f():
     ```

     

# 函数进阶

### 回调函数

1. 定义：将一个函数以参数的形式传入到另一个函数中，并在那个函数中执行，这样叫做回调

   ```
   function fn1(fn){
   	fn();
   }
   function fn2(){
   	cosole.log("aaa");
   }
   fn1(fn2);
   ```

2. 应用：

   + 回调一般用于当处理某件事情需要等待时，设置回调，下面的两个方法均是回调的应用

   + 当不需要关心具体后续需要处理的事情时，设置回调

     类似游戏插槽，主机并不关心是什么游戏，插什么卡，处理什么游戏

     ```
     function setLight(){
     	arguments[0]();
     	arguments[1]();
     	arguments[2]();
     }
     function redLight(){
     	console.log("红灯");
     }
     function yellowLight(){
     	console.log("黄灯");
     }
     function greenLight(){
     	console.log("绿灯");
     }
     setLight(redLight,yellowLight,greenLight);
     
     ```

   ###### 两个方法

   1. setTimeout(超时执行的函数，超时时间，执行函数的参数)    返回一个ID数    异步执行

      ```
      var id = setTimeout(fn,2000,5)
      
      console.log("a")
      function fn(n){
      	console.log(n);
      	clearTimeout(id);//清除时间间隔，清除这个超时函数
      }
      console.log("b");
      console.log(id);
      //打印a和b，过两秒（2000ms）打印出5
      ```

   2. setInterval(执行函数，间隔时间)，每过一段时间，就执行fn函数

      ```
      var id = setInterval(fn,2000)
      var num = 0;
      function fn(){
      	num++;
      	console.log("aa");
      	if(num>5) clearInterval(id);
      }
      ```

   ###### 案例1 红绿灯 

   + 利用回调，将异步变成同步等待，异步时如何处理一个接一个的问题

     ```
    function 
     ```
   
     
   
   ###### 案例2 累加
   
   + 使用回调的时候要注意return到了哪里

### 递归函数

1. 函数内部执行自身，叫做递归

   ```
   var i = 0;
   function fn1(){
   	i++;
   	if(i<3) fn1();
   	console.log(i);
   }
   fn1();
   //输出3 3 3
   ```

   递归的层数不能太多，会造成堆栈上限溢出，根据内存大小，递归次数的上限也不一样

### 函数的声明

1. 普通函数声明

2. 匿名函数声明（1）

   ```
   var box=function(num1,num2){
          retrun num1+num2;
   }
   ```

   匿名函数声明（2）

   ```
   var obj={
   	name:”zhangsan”,
   	fire:function(num1,num2){
   	        var s=num1+num2;
   		return s;
   	}
   }
   ```

4. Function构造函数

### 工厂型创建对象

### 函数的执行

### 函数的删除

+ 只有函数是匿名定义的或者通过构造函数创建的才可以被删除

1. 匿名函数删除：函数=null
2. 对象下的方法删除： delete obj.fn;

### 函数对象

1. 函数也是一个对象，可以为他定义属性和方法
2. 如果要执行函数使用fun1()，但是要调用函数的方法或者属性的时候，就不能加小括号了，因为fun1才是对象，加上小括号是获取执行结果
3. 函数也是对象，每个对象都包含两个属性：length和prototype，其中length表示函数希望接收的命名参数的个数

### 内存管理



# 构造函数

### 构造函数

1. 通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性。
2. 原型内方法地址是否一样？？
3. 

### 实例化对象

### 原型对象



# 数组

1. 数组和对象

   + 数组
     + 有序的列表存储若干个无序的元素，紧凑型结构
     + 删除一个元素时，后面的元素就向前递进
     + 数组有长度arr.length
     + 插入和删除都会影响数组的位置和结构，因此数组的运行效率时间复杂度较高
     + 存储依靠下标，如果需要查找一个元素，需要遍历数组的每个元素
     + 数据的关联性比较强，比如排好序的数组，可以轻易查找比特定元素大（小）的值

   + 对象
     + 是一种松散型结构，对象的属性是键值存储
     + 删除一个元素时，对象的其他值不会发生变化
     + 对象没有长度，没有obj.length
     + 插入和删除不会影响其他数据，因此对象的时间复杂度极低
     + 对象是通过键值对存储，获取时只需要根据key去获取即可
     + 数据关联性比较弱，数据独立存在，不能排序，不能查找关联关系对应的值

2. 数组的元素简称元，访问方式arr[index]，这种方式叫做下标变量

### 创建数组

1. JavaScript是弱类型，数组中可以同时存储各种类型的数据，但是运行效率极低，数组存储时要注意考虑数组的用途和数据类型

2. 数组可以任意扩张，不需要限定长度

3. 创建数组的方式

   + 字面量创建数组```var arr = [1,2,3]```
   + 构造函数创建数组```var arr = new Array(1,2,3)```
     1. 缺点：构造函数创建数组时只有一个自然数参数，则这个参数代表数组的长度，数组为空，如果是负数或者小数，就会报错。如果是非数值，就会作为数组中的第一个元素
   + 对象创建法```var arr = new Object([]);```

4. ```typeof arr```会输出object，区分数组和对象的方法：

   + ```console.log(arr.constructor === Array)```，最保险
   + ```console.log.lig(Array.isArray(arr))```，ES6以后支持
   + ```console.log(String(arr) !== "[object object]")```，对象转换为字符串是```[object Object]```，数组转换为字符串时，都会转换为数组的元素连接成的字符串

5. 数组也是对象，也是引用地址赋值

   ```
   console.log([] === []);  //false
   console.log([] == []);   //false
   
   console.log(![] == []);  //true
   左右两边类型不一样，数组会转换为字符串
   左边：
   ![] ---->  false  还没进行比较，只是!，所以不会转换为字符串，[]也是对象，对象转换为布尔值是true，！就是false
   右边：
   [] ---->  "" ---->  false
   
   [] ~ ""、false、0 ----> true
   ```


6. 数组在强转或者隐式转换为字符串时，都会转换为数组的元素连接成的字符串

### 数组的属性

+ 静态方法（Array.isArray()）和实例方法（arr.reduce()）

1. arr.length

   + 可读可写

   + 如果设置的length比原本数组的长度小，那么就会删除尾部的元素

   + ```arr.length = 0;```清空数组中所有元素

   + 如果设置的length比原本数组的长度大，那么就会在尾部添加空元素

   + 在数组尾部添加一个元素```arr[arr.length] = 5;```

   + 数组下标大于数组的长度时，对应下标增加元素，中间增加空元素（空元素输出undefined）

   + 数组元素为undefined和空元素```arr[i] === undefined```都是true


### 数组的方法

1. **concat()**，拼接两个或者更多数组并返回新数组，也可以直接拼接元素，与原数组没有引用关系

   concat拼接是在调用这个方法的数组的length后面拼接其他数组，如果arr1的实际长度为5，设置length长度为20，那么arr2就会在20后面进行拼接

   **重构**

   ```
   function concat(arr) {
   	var arr1 = [];
   	for (let i = 0; i < arr.length; i++) arr1[i] = arr[i];
   
   	for (let i = 1; i < arguments.length; i++) {
   		if (arguments[i] !== null && arguments[i].constructor === Array) {
   			for (let j = 0; j < arguments[i].length; j++) {
   				arr1[arr1.length] = arguments[i][j];
   			}
   		} else {
   			arr1[arr1.length] = arguments[i];
   		}
   	}
   	return arr1;
   }
   ```

   

2. entries()，从数组创建了一个可迭代的对象，该对象包含了数组的键值对

3. **every()**，检测数值元素的每个元素是否都符合条件，不会改变原始数组，也不会对空数组进行检测，需要数组中的每个元素均符合条件才返回true

   **重构**

   ```
   function every(arr,fn){
   	for(var i = 0;i<arr.length;i++){
   		if(i in arr && !fn(arr[i],i,arr)) return false;
   	}
   	return true;
   }
   ```

   

4. **some()**，检测数组中是否有满足指定条件的元素，如果有一个元素满足条件，就返回true，剩下的元素不会再进行检测，如果没有返回false

   **重构**

   ```
   function some(arr,fn){
   	for(var i = 0;i<arr.length;i++){
   		if(i in arr && fn(arr[i],i,arr)) return true;
   	}
   	return false;
   }
   ```

   

5. **fill()**，使用固定值填充数组

   第二个参数和第三个参数，分别表示起始位和结束位，第一个参数表示要填充的值

   只能用于有长度的数组

   如果填充的是对象，就会填充为同一个引用地址的对象

6. **filter()**，创建一个新的数组，新数组中的元素时是通过检查指定数组中符合条件的所有元素筛选

   数组是新的，里面的元素还是原来的，如果元素是对象的话，改返回的数组就会改原数组

   **重构**

   ```
   function filter(arr,fn){
   	var arr1 = [];
   	if(arr.length===0) return arr1;
   	for(var i = 0; i<arr.length;i++){
   		if(fn(arr[i], i, arr)) arr1.push(arr[i]);
   	}
   	return arr1;
   }
   ```

   

7. find()，会返回filter方法结果的第一个元素，即获取数组满足条件的第一个元素

8. findIndex()，返回find结果元素的索引,下标从零开始

9. **forEach()**，数组每个元素都执行一次回调函数，调用数组的每个元素，并将元素传递给回调函数，forEach对于空数组是不会执行回调函数的，该方法不会修改数组元素

   **重构**

   ```
   function forEach(arr, fn) {
   	for (var i = 0; i < arr.length; i++) {
   		if (i in arr) fn(arr[i], i, arr)
   	}
   }
   ```

   

10. includes()，判断一个数组是否包含一个指定的值，如果是返回true

11. **indexOf()**，搜索数组中的元素，并返回它的位置，相当于返回includes的下标

    可以接收第二个参数，表示从第几个下标开始

    **重构**

    ```
    function indexOf(arr, search, index) {
    	if (index === undefined) index = 0;
    	for (var i = index; i < arr.length; i++) {
    		if (arr[i] == search) return i;
    	}
    	return false;
    }
    ```

    

12. isArray()，判断对象是否是数组

13. **join()**，使用某个字符作为连结符，将所有数组元素连接成为一个字符串并且返回，默认逗号连接

    **重构**

    ```
    function join(arr, connector) {
    	if (connector === undefined) connector = ",";
    
    	var str = '';
    	for (var index in arr) {
    		if (index == arr.length - 1) {
    			str += arr[index]; 
    			break;
    		}
    		str = str + arr[index] + connector;
    	}
    	return str;
    }
    ```

    

14. keys()，返回数组的可迭代对象，包含原始数组的key

15. **lastIndexOf()**，返回一个指定的元素在数组中最后出现的位置，如果没有查找到返回-1

    **重构**

    ```
    function lastIndexOf(arr, search, index) {
    	if (index === undefined) index = 0;
    	for (var i = arr.length; i >= 0; i--) {
    		if (arr[i] == search) return i;
    	}
    	return false;
    }
    ```

    

16. map()，返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值，但是不会改变原始数组，map方法按照原始数组的元素顺序依次处理元素，map不会对空数组进行检测，一定要使用返回

    **重构**

    ```
    function map(arr, fn) {
    	var arr1 = [];
    	for (var i = 0; i < arr.length; i++) {
    		if (i in arr) arr1[i] = fn(arr[i], i, arr);
    	}
    	return arr1;
    }
    ```

    

17. **pop()**，删除数组的最后一个元素并返回删除的元素，没有参数

    ```
    可以删除到指定元素，使用pop加循环
    while(arr.pop() ！== 3)  //删除到值为3的元素为止，3也会被删掉
    
    数组返回undefined的情况：空元素，元素值为undefined，空数组
    
    删除数组为空，使用循环加length一个一个向前删除
    while(arr.length>0){
    	arr[arr.length-1] = null;//考虑到数组中可能存储的是对象
    	arr.pop()
    }
    
    下面这种写法效率更高
    for(let i = 0;i<arr.length;i++){
    	arr[i] = null;
    }
    arr.length = 0
    ```

    **重构**

    ```
    function pop(arr){
    	var elem = arr[arr.length-1];
    	if(arr.length>0) arr.length--;
    	return elem;
    }
    ```

    

18. **shift()**，删除并返回数组的第一个元素，并且返回这个元素，此方法改变数组的长度

    一般不使用，因为效率低下

19. **push()**，向数组的末尾添加一个或**更多元素**，并返回新的长度

    ```
    while(arr.push(1)<10)//循环给数组为组添加若干个元素，直到数组的长度为10
    while(arr.push({})<10)//添加的对象不具有引用关系
    ```

    **重构**

    ```
    function push(arr) {
    	for (let i = 1; i < arguments.length; i++) {
    	arr[arr.length] = arguments[i];//将传进来的参数一个一个遍历，然后添加进arr数组
    	}
    	return arr.length;//返回添加后数组的长度
    }
    ```

    

20. **unshift()**，向数组的开头添加一个或更多元素，并返回新的长度

    一般不使用，因为效率低下

    **重构**

    ```
    // 第一种方式，将原数组的元素从后往前依次后移一定的位数，然后将参数添加到数组前面
    function unshift(arr) {
    	var len = arr.length;
    	for (let i = len - 1; i >= 0; i--) {
    		arr[i + arguments.length - 1] = arr[i];
    		arr[i] = null;
    	}
    	for(let i = 0;i<arguments.length-1;i++){
    		arr[i] = arguments[i+1];
    	}
    	return arr.length;
    }
    
    // 第二种方式，拼接的方式，先将原数组的所有元素放在一个新数组中，然后将原数组清空，再将添加的元素放入原数组，最后再将新数组中存储的原数组最初的元素拼接在后面
    function unshift(arr) {
    	var arr1 = [];
    	var N = arguments.length;
    	for (let i = 0; i < arr.length; i++) {
    		arr1[i] = arr[i];
    		arr[i] = null;
    	}
    	arr.length = 0;
    	for (let i = 1; i < N; i++) {
    		arr[i - 1] = arguments[i];
    	}
    	for (let i = 0; i < arr1.length; i++) {
    		arr[i + N - 1] = arr1[i];
    	}
    	return arr.length;
    }
    ```

    

21. **reduce()**，将数组元素计算为一个值，从左向右，使用返回，value和item必需，底层是用Number对其他非数值类型数组元素进行转换：因为null相加转换为了0，undefined转换为了NaN

    + 没有初始值的时候。value值就是数组的第0位元素

    + 遍历的第二次运行的时候，value的值是上次遍历return的结果

    + 每个数组遍历完成以后，将最后一次的返回值返回到外面

    ```
    利用reduce求数组最大值
    var max = arr.reduce(function (value, item, index, arr) {
    	return value > item ? value : item;
    })
    
    当使用reduce设置初始值的时候，value就等于初始值，并且遍历会从第0项开始遍历
    
    利用reduce同时求最大值和最小值
    
    reduce不只是能求和，归并的意思是求一个单个的个体
    // 利用reduce，查找出京东
    var arr = [
    { id: 1001, name: "苹果IphoneX", price: 6900, num: 2, info: "最新的苹果手机" },
    { id: 1002, name: "小米10", price: 3900, num: 3, info: "最新的小米手机" },
    { id: 1003, name: "华为meta10", price: 8900, num: 4, info: "最新的华为手机" },
    { id: 1004, name: "锤子手机", price: 1900, num: 1, info: "最新的锤子手机" },
    { id: 1005, name: "三星手机", price: 4900, num: 2, info: "最新的三星手机" },
    { id: 1006, name: "vivo手机", price: 2900, num: 4, info: "最新的vivo手机" },
    { id: 1007, name: "魅族手机", price: 1900, num: 5, info: "最新的魅族手机" },
    ];
    var obj = arr.reduce(function(value,item){
    	if(item.site="京东") value=item;
    	return value;
    })
    console.log(obj);
    ```

    **重构**

    ```
    function reduce(arr,fn,initValue){
    	var index=0;
    	if(initValue===undefined){
    		initValue=arr[0];
    		index=1;
    	}
    	for(;index<arr.length;index++){
    		initValue=fn(initValue,arr[index],index,arr);
    	}
    	return initValue;
    }
    ```

    

22. reduceRight()，将数组元素计算为一个值，从右向左，使用方法同上

23. **reverse()**，反转数组的元素顺序

    **重构**

    ```
    function reverse(arr) {
    	var N = arr.length;
    	var arr1 = [];
    	for (let i = 0; i < N; i++) {
    		if (i in arr) arr1[i] = arr[i];
    	}
    	arr.length = 0;
    	for (let i = N - 1; i >= 0; i--) {
    		if (i in arr1) arr[N - 1 - i] = arr1[i];
    	}
    	return arr;
    }
    
    ```

    

24. **slice()**，切割数组，从已有的数组中返回选定的元素，返回选定的元素组成的数组，不会改变原始数组

    + ```arr.splice()```，可以复制新数组，或者只有一个参数为0
    + 一个参数的时候，表示起始位，复制到结尾
    + 可接受负数，表示倒数

    **重构**

    ```
    function slice(arr, start, end) {
    	var arr1 = [];
    	var N = arr.length;
    	if (start === undefined) start = 0;
    	if (end === undefined) end = N -1;
    
    	start = Number(start);
    	end = Number(end);
    
    	if(!isNaN(start) && isNaN(end)) start = 0;
    	if(isNaN(start)) return [];
    
    	if (start < 0) start = N + start;
    	if (end < 0) end = N + end;
    
    	for (let i = 0; i <= end - start; i++) {
    		arr1[i] = arr[start + i];
    	}
    	return arr1;
    }
    ```

    

25. **sort()**，对数组元素进行排序

26. **splice()**，删除元素，并向数组中添加一个或多个新元素，返回被删除的元素组成的新数组

    splice()从哪开始删除元素a，删除多少元素b，要添加的元素c)

    + 不给参数，不删除元素，没有删除就返回空数组
    + 不给b就删除到最后一个元素，b设置为arr.length就是删除到数组尾部，不给c就是只删除
    + 第一个参数是负数，表示从后向前数开始删除；第一个参数为0，将一个数组的所有元素转移到新数组
    + b如果是负数，不报错，但是也不起作用；b为0，只插入
    + 这种方法会改变原始数组
    + 时间复杂度太高，尽量不用

27. toString()，将数组转换为字符串并返回结果

+ unshift()，shift()，push()，pop()不改变原数组的引用关系，改变原数组

##### 随机乱序

俄罗斯轮盘赌

##### 索引查找对象

1. 不要用indexOf查找对象，因为只要引用地址不一样，判断就会认为两个对象不相等
2. 可以给数组中的对象添加一个值为数值类型的属性，比如id，然后使用这个唯一标识进行查找
3. 不能使用id的时候，就遍历，然后将需要查找的字符串和数组中的对象转换成字符串进行比对

#### 数组方法的实现 

+ push、pop、unshift、shift、concat
+ 需要注意的问题：参数是一个元素，参数没有元素，参数是数组，参数有多个

### 排序

1. 冒泡排序

   ```
   function mao(arr) {
   	var len = arr.length;
   	var temp;
   	while (len > 0) {
   		for (var i = 0; i < len-1; i++) {
   			if(arr[i]>arr[i+1]){
   				temp = arr[i];
   				arr[i] = arr[i+1];
   				arr[i+1] = temp;
   			}
   		}
   		len--;
   	}
   	return arr;
   }
   ```

   

2. 选择排序

   ```
   function selectionSort(arr) {
   	var minIndex;
   	var N = arr.length;
   	var temp;
   	for (let i = 0; i < N; i++) {
   		minIndex = i;
   		for (var j = i; j < N; j++) {
   			if (arr[minIndex] > arr[j]) minIndex = j;
   		}
   		if (minIndex != i) {
   			temp = arr[minIndex];
   			arr[minIndex] = arr[i];
   			arr[i] = temp;
   		}
   	}
   	return arr;
   }
   ```

   

3. 快速排序

   ```
   function quickSort(arr) {
   	if (arr.length <= 1) return arr;
   	var pivotIndex = Math.floor(arr.length / 2);
   	var pivot = arr.splice(pivotIndex, 1)[0];//取出中间的那个元素          
   	var left = [],
   	right = [];
   	for (var i = 0; i < arr.length; i++) {
   		if (arr[i] < pivot) left.push(arr[i]);
   		else right.push(arr[i]);
   	}
   	return quickSort(left).concat(pivot, quickSort(right));
   }
   ```

   

### 数组的遍历

1. 数组使用for循环遍历，使用下标遍历，不遍历数组点语法添加的属性，但是会遍历到空元素，遍历时下标都是数值

2. 数组使用for-in循环遍历，会遍历所有的可枚举属性，没有值就不遍历，遍历时下标都是字符串

3. forEach()，自动回避空元素

   ```
   var arr = [1,2,3,4,5];
   arr.forEach(function(item,index,arr){
   	//item = 10;   错误
   	arr[index] = item +10;//正确
   })
   
   重构后就能理解为什么item=10是错误的，因为作为参数的那个函数是没有返回值的，而数值又不是引用类型，所以item=10错误，因为只在该函数内部修改了局部变量
   ```

   不能遍历数组的属性，不会遍历到空元素

   缺陷：函数中this指向将会被改变

4. map()，遍历数组，参数（那个函数）使用return返回各个元素执行函数的结果，map返回这些结果组成的新数组，新数组的长度和原数组一致，自动回避空元素

   ```
   var arr = [1,2,3,4,5]
   var arr1 = arr.map(function(item,index,arr){
   	return item+10;
   })
   ```

   使用delete删除数组元素后，数组会从紧密型变为松散型

#### 桥接模式



### 函数中的call和apply

1. ```B.apply(A, arguments)```，即A对象调用B对象的方法，可传入数组

   ```B.call(A, argu1, argu2, argu3, ...)```，即A对象调用B对象的方法

2. 参数大于3的时候，call的性能优于apply

3. 案例1

   ```
   function add(a,b){
   	return a+b;
   }
   function sum(a,b){
   	return a-b;
   }
   var a1 = add.apply(sum,[8,4]);	//12
   var a2 = sum.call(add,8,4);	//4
   ```

   

4. 案例2

   ```
   var name = "我是全局的",
   	age = 18;
   	
   var obj = {
   	name : "我是obj里面的",
   	myFunction: function(){
   		console.log(this.name + this.age);
   	}
   }
   
   var db = {
   	name : "我是db里面的",
   	age : 30
   }
   obj.myFunction();			//obj
   obj.myFunction.call();		//全局
   obj.myFunction.call(db);	//db
   ```

   

5. 案例3

   ```
   fucntion A(){
   	this.name = "Kevin",
   	this.showName = function(){
   		console.log(this.name)
   	}
   }
   function B(){
   	this.name = "Bob",
   	A.call(this)
   }
   var B = new B();
   B.showName();    //Kevin
   ```

   

### 函数的绑定



### 二维数组

1. 二维数组的创建

   + 方法1：```var a = [ [ 1,2 ], [ 3,4 ] ];```

   + 方法2：```var a = new Array( new Array(1,2), new Array(3,4) );```

   + 方法3：

     ```
     var a = new Array();				//先声明一维数组
     for(var i=0;i<5;i++) {
         a[i] = new Array(i);			//再声明二维数组
         for(var j=0;j<5;j++) {
         	a[i][j] = i;				//赋值
         }
     }
     ```

2. 遍历二维数组，两个for循环嵌套

   ```
   for(var i=0;i<a.length;i++) {
   	for(var j=0;j<a[i].length;j++) console.log( a[i][j] );
   }
   ```


3. 二维数组的方法

   + 扁平化数组flatMap()

     ```
     var arr1 = arr.flatMap(function(item){
     	console.log(item)
     })
     console.log(arr1);//将二维数组合并为一个数组
     ```

   + flatMap方法重构

     ```
     function flatMap(arr) {
     	var arr_new = [];
     	for (var i = 0; i < arr.length; i++) {
     		if (arr[i].constructor !== Array) {
     			arr_new[arr_new.length] = arr[i];
     			continue;
     		}
     		for (var j = 0; j < arr[i].length; j++) {
     			arr_new[arr_new.length] = arr[i][j];
     		}
     	}
     	return arr_new;
     }
     ```

     

### 对象数组

### 对象数组

1. 数组中放置对象，元素是引用地址

# 内建对象

### Math

#### 属性

1. Math.E返回自然对数的底数，约等于2.718
2. Math.LN2返回2的自然对数，约等于0.693
3. Math.LN10返回10的对数，约等于2.302
4. Math.LOG2E返回以2为底E的对数，约等于1.4427
5. Math.LOG10E返回以10为底E的对数，约等于0.434
6. Math.PI返回圆周率
7. Math.SQRT1_2返回2的平方根的倒数，约等于0.707
8. Math.SQRT2返回2的平方根，约等于1.414

+ 6,7,8比较常用

**代码**

```
console.log("Math.E: "+Math.E);

console.log("Math.LN2: "+Math.LN2);

console.log("Math.LN10: "+Math.LN10);

console.log("Math.LOG2E: "+Math.LOG2E);

console.log("Math.LOG10E: "+Math.LOG10E);

console.log("Math.PI: "+Math.PI);

console.log("Math.SQRT1_2: "+Math.SQRT1_2);

console.log("Math.SQRT2: "+Math.SQRT2);
```

**运行结果**

![](D:\GP-2002\笔记\img\内置对象-Math-属性.png)

#### 方法

1. **abs(x)**返回数的绝对值，不推荐使用，需要使用绝对值的时候，可以使用三目运算符

2. acos(x)返回数的反余弦值

   ![](D:\GP-2002\笔记\img\反余弦.jpg)

3. asin(x)返回数的反正弦值

   ![](D:\GP-2002\笔记\img\反正弦函数.gif)

4. atan(x)以介于-π/2和π/2弧度之间的数值来返回x的反正切值

5. atan2(x)返回从x轴到点(x,y)的角度（介于-π/2和π/2弧度之间）

6. **ceil(x)**对数进行上舍入

7. **floor(x)**对数进行下舍入

8. cos(x)返回数的余弦值

9. exp(x)返回e的指数值

10. log(x)返回数的自然对数，底为e

11. **max(x,y)**返回两个值中最大值，参数可以有若干个，两个比较直接使用三目运算

12. **min(x,y)**返回两个值中最小值，参数可以有若干个

    ```
    求数组的最大值和最小值
    var max = Math.max.apply(null,arr);
    var min = Math.min.apply(null,arr);
    ```

    

13. **pow(x,y)**返回x的y次幂，尽量减少pow的使用，效率低，y=1/3，开立方根

14. **random()**返回0-1之间的随机数

15. **round(x)**把数四舍五入为最接近的整数，负数是无法进行四舍五入的

    负数做四舍五入

    -3.5  ---->  -4+0.5  ---->  -4不变，0.5入为1  ---->  -4+1=-3  ===>  -3.5四舍五入为-3

16. sin(x)返回数的正弦

17. **sqrt(x)**返回数的平方根

18. tan(x)返回角的正切

**代码**

```
console.log("abs: "+Math.abs(-999));

console.log("acos: "+Math.acos(1));

console.log("asin: "+Math.asin(0.5));

console.log("atan: "+Math.atan(0.5));

console.log("atan2: "+Math.atan2(4,3));

console.log("ceil: "+Math.ceil(5.122));

console.log("floor: "+Math.floor(5.99));

console.log("cos: "+Math.cos(Math.PI));

console.log("exp: "+Math.exp(1));

console.log("log: "+Math.log(Math.E));

console.log("max: "+Math.max(5,9));

console.log("min: "+Math.min(5,9));

console.log("pow: "+Math.pow(2,3));
        
console.log("random: "+Math.random());

console.log("round: "+Math.round(5.66));

console.log("sin: "+Math.sin(Math.PI/2));

console.log("sqrt: "+Math.sqrt(16));

console.log("tan: "+Math.tan(0));
```



**运行结果**

![](D:\GP-2002\笔记\img\内置对象-Math-方法.png)

### String

+ 可以使用```str[1]```获取字符串中的字符，不能使用```str[1]="e"```，禁止，也无效

#### 属性

length，只读，无法修改

#### 方法

+ 字符串的方法均不能修改原字符串

1. **charAt()**返回在指定位置的字符，等同于```str[i]```

2. **charCodeAt()**返回在指定的位置的字符的Unicode编码

3. **concat()**连接字符串，等同于```str+="dsdf"```

4. **fromCharCode()**从字符编码创建一个字符串

5. **indexOf()**检索字符串,返回某个指定的字符串值在字符串中首次出现的位置，没有找到返回-1，，如果有重复的值，返回前面的，第二个参数可以指定查找的起始位

   **模糊查询**

   ```
    var arr = [
   { id: 1001, name: "苹果IphoneX", price: 6900, num: 2, info: "最新的苹果手机" },
   { id: 1002, name: "小米10", price: 3900, num: 3, info: "最新的小米手机" },
   { id: 1003, name: "华为meta10", price: 8900, num: 4, info: "最新的华为手机" },
   { id: 1004, name: "锤子手机", price: 1900, num: 1, info: "最新的锤子手机" },
   { id: 1005, name: "三星手机", price: 4900, num: 2, info: "最新的三星手机" },
   { id: 1006, name: "vivo手机", price: 2900, num: 4, info: "最新的vivo手机" },
   { id: 1007, name: "魅族手机", price: 1900, num: 5, info: "最新的魅族手机" },
   ];
   var arr1 = arr.filter(function(item){
   	return item.name.indesOf("手")>-1;;
   })
   ```

   #### 数据驱动显示

   

6. **lastIndexOf()**从后向前检索字符串,,返回某个指定的字符串值在字符串中首次出现的位置，没有找到返回-1，如果有重复的值，返回后面的

7. **replace()**替换第一个与正则表达式匹配的子串

   match()，字符串的正则表达式，将查找的结果以数组的形式返回

8. **search()**检索与正则表达式向匹配的值,返回某个指定的字符串值在字符串中首次出现的位置

9. **slice()**提取字符串的判断，并在新的字符串中返回被提取的部分，只能从前向后选

10. **split()**把字符串分割为字符串数组，跟数组的join相反

    ```
    字符串的反转
    var str = "abcdefg"
    str = str.split("").reverse().join("");
    ```

11. **substr()**从起始索引号提取字符串中指定数目的字符

12. **substring()**提取字符串中两个指定的索引号之间的字符，不支持负数，负数代表最前面，智慧从后向前选，start>end即可，注：不是节选的字符串颠倒

13. toLocaleLowerCase()把字符串转换为小写

14. toLocaleUpperCase()把字符串转换为大写

15. **toLowerCase()**把字符串转换为小写

16. **toUpperCase()**把字符串转换为大写

**代码**

```
var str = "lilan wuyuanyuan zhuyaoru duzijing wuyuanyuan"

console.log("length: " + str.length);

console.log("charAt: " + str.charAt(4));

console.log("charCodeAt: " + str.charCodeAt(4));

console.log("concat: " + 'name:'.concat(str));

console.log("fromCharCode: " + String.fromCharCode(65));

console.log("indexOf: " + str.indexOf('wuyuanyuan'));

console.log("lastIndexOf: " + str.lastIndexOf('wuyuanyuan'));

console.log("replace: " + str.replace('wuyuanyuan', 'fusiyu'));

//将数组回归原样
str.replace('fusiyu: ', 'wuyuanyuan')

console.log("search: " + str.search('wuyuanyuan'));

console.log("slice: " + str.slice(2, 10));

console.log("split: " + str.split(" "));

console.log("substr: " + str.substr(2, 3));

console.log("substring: " + str.substring(2, 3));

console.log("toLocaleLowerCase: " + str.toLocaleLowerCase());

console.log("toLocaleUpperCase: " + str.toLocaleUpperCase());

console.log("toLowerCase: " + str.toLowerCase());

console.log("toUpperCase: " + str.toUpperCase());
```



**运行结果**

![](D:\GP-2002\笔记\img\内置对象-String.png)

### Number

#### 属性

1. Number.MAX_VALUE，正数的最大值
2. Number.MIN_VALUE，正数的最小值
3. Number.Nan，跟NaN一样

#### 方法

1. toFixed(number)

   参数为浮点位，表示小数点后面保存的位数，15~15.00，自动四舍五入

   a = a.toFixed(2)

2. toExponential()

   + 将数值格式化为科学计数法
   + 参数值的范围是0~20
   + 参数值表示科学计数法小数点后面的位数，当数值的位数超出参数指定范围的时候，进行四舍五入

3. toPrecision()

   + 将数值格式化为指定的长度，参数字、表示长度
   + 当对象的值超出指定位数时，将其格式化为科学计数法，不够的时候用小数点后面的0来凑
   + 参数1-21


### Date 

#### 属性

**代码**

```
// 获取时间对象
var date = new Date()

// 时间的获取方法
console.log("Date: " + Date());   

console.log("getDate: " + date.getDate());//返回年月日中的日
console.log("getDay: " + date.getDay());//返回周几，从周日起算，周日为0
console.log("getMonth: " + date.getMonth());//返回月份,0-11,12月为0
console.log("getFullYear: " + date.getFullYear());//返回年份
console.log("getHours: " + date.getHours());//返回小时，24小时制
console.log("getMinutes: " + date.getMinutes());//返回分钟数
console.log("getSeconds: " + date.getSeconds());//返回秒数
console.log("getMilliseconds: " + date.getMilliseconds());//返回毫秒，0-999
console.log("getTime: " + date.getTime());//返回从1970-1-1至今的毫秒数，时间戳
console.log(date.toLocaleString())//转换为本地时间
console.log(date.toUTCString())//转换为格林尼治时间
```

时间戳可以用来清缓存、可用来计算代码的效率（运行前后 时间戳的差值）

每次new Date()就会获取new这个时间的当时值，```var date = new Date()```，不管打印多少遍date，都是一样的



**运行结果**

![](D:\GP-2002\笔记\img\内置对象-Date-属性.png)

#### 方法

**代码**

```
console.log("getDate: " + date.getDate());
date.setDate(20)
console.log("getDate: " + date.getDate());

console.log("getMonth: " + date.getMonth());
date.setMonth(11)
console.log("getMonth: " + date.getMonth());

console.log("getFullYear: " + date.getFullYear());
date.setFullYear(2000)
console.log("getFullYear: " + date.getFullYear());

console.log("getHours: " + date.getHours());
date.setHours(20)
console.log("getHours: " + date.getHours());

console.log("getMinutes: " + date.getMinutes());
date.setMinutes(100)//设置的值超出60的时候，会对60取模
console.log("getMinutes: " + date.getMinutes());

console.log("getSeconds: " + date.getSeconds());
date.setSeconds(80)
console.log("getSeconds: " + date.getSeconds());

console.log("getMilliseconds: " + date.getMilliseconds());
date.setMilliseconds(200)
console.log("getMilliseconds: " + date.getMilliseconds());

console.log("getTime: " + date.getTime());
date.setTime(1000000)
console.log("getTime: " + date.getTime());
console.log("date: " + date)
```

**运行结果**

![](D:\GP-2002\笔记\img\内置对象-Date-方法.png)

### 随机色

+ 第一种方法

```
function randomColor(){
	var col="#";
	for(var i=0;i<6;i++){
		col+=Math.floor(Math.random()*16).toString(16);
	}
	return col;
}
   
   
   
function randomColor(){
	return "#"+Array(6).fill(Math.floor(Math.random()*16).toString(16))
}
```

+ 第二种

```
function randomColor(){
	var col="rgb";
	for(var i=0;i<3;i++){
		col+=Math.floor(Math.random()*256)+",";
	}
	col = col.slice(0,-1);
	return col;
}
```

















# 案例

[秒表](./案例/秒表.html)



